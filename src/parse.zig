// Copyright (c) 2025 g41797
// SPDX-License-Identifier: MIT

const std = @import("std");
const ascii = std.ascii;
const err = @import("err.zig");
const ReturnedError = err.ReturnedError;

// Server messages:
// INFO {"option_name":option_value,...}␍␊
// PING␍␊
// PONG␍␊
// +OK␍␊
// -ERR <error message>␍␊
// MSG <subject> <sid> [reply-to-subject] <#bytes>␍␊
// [payload]␍␊
// HMSG <subject> <sid> [reply-to-subject] <#header bytes> <#total bytes>␍␊
// [headers]␍␊␍␊
// [payload]␍␊
//
// subject  - non-empty alphanumeric strings with no embedded whitespace
// sid      - a unique alphanumeric subscription ID, generated by the client

pub fn count_substrings(line: []const u8) !u16 {
    _ = line;
    return ReturnedError.Unknown;
}


pub fn cut_head(line: []const u8) !struct { head: []const u8, tail: []const u8 } {
    _ = line;
    return ReturnedError.Unknown;
}

pub fn cut_tail_size(line: []const u8) !struct { shrinked: []const u8, size: usize } {
    if (line.len == 0) {
        return ReturnedError.Unknown;
    }

    var sizeIndex: usize = 0;
    if (std.mem.lastIndexOfScalar(u8, line, ' ')) |val| {
        sizeIndex = val;
    } else {
        return ReturnedError.Unknown;
    }

    var size: usize = 0;
    var lenOfsize = line.len - sizeIndex - 1;

    for (line[sizeIndex + 1 .. line.len], 0..) |char, indx| {
        if ((char == '\r') or (char == '\n')) {
            lenOfsize = indx;
            break;
        }
    }

    if (std.fmt.parseInt(usize, line[sizeIndex + 1 .. sizeIndex + 1 + lenOfsize], 10)) |parsed| {
        size = parsed;
    } else |parseErr| {
        return parseErr;
    }

    return .{ .shrinked = line[0..sizeIndex], .size = size };
}
