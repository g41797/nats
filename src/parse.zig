// Copyright (c) 2025 g41797
// SPDX-License-Identifier: MIT

const std = @import("std");
const ascii = std.ascii;
const err = @import("err.zig");
const ReturnedError = err.ReturnedError;

// Server messages:
// INFO {"option_name":option_value,...}␍␊
// PING␍␊
// PONG␍␊
// +OK␍␊
// -ERR <error message>␍␊
// MSG <subject> <sid> [reply-to-subject] <#bytes>␍␊
// [payload]␍␊
// HMSG <subject> <sid> [reply-to-subject] <#header bytes> <#total bytes>␍␊
// [headers]␍␊␍␊
// [payload]␍␊
//
// subject  - non-empty alphanumeric strings with no embedded whitespace
// sid      - a unique alphanumeric subscription ID, generated by the client

pub fn count_substrings(line: []const u8) u16 {
    const trl = std.mem.trim(u8, line, " \t\r\n");

    if (trl.len == 0) {
        return 0;
    }

    var subs_it = std.mem.splitAny(u8, trl, " \t");

    var count: u16 = 1;
    _ = subs_it.first();

    while (true) {
        if (subs_it.next()) |*val| {
            if (val.len > 0) {
                count += 1;
            }
        } else {
            return count;
        }
    }
}

pub fn cut_tail_size(line: []const u8) !struct { shrinked: []const u8, size: usize } {
    const subs = try cut_tail(line);

    var size: usize = 0;

    if (std.fmt.parseInt(usize, subs.tail, 10)) |parsed| {
        size = parsed;
    } else |parseErr| {
        return parseErr;
    }

    return .{ .shrinked = subs.shrinked, .size = size };
}

pub fn cut_tail(line: []const u8) !struct { shrinked: []const u8, tail: []const u8 } {
    const trl = std.mem.trim(u8, line, " \t\r\n");

    if (trl.len == 0) {
        return error.EmptyLine;
    }

    var tailIndex: usize = 0;
    if (std.mem.lastIndexOfScalar(u8, trl, ' ')) |val| {
        tailIndex = val;
    } else {
        return error.BadFormat;
    }

    var lenOfTail = trl.len - tailIndex - 1;

    for (line[tailIndex + 1 .. trl.len], 0..) |char, indx| {
        if ((char == '\r') or (char == '\n')) {
            lenOfTail = indx;
            break;
        }
    }

    return .{ .shrinked = trl[0..tailIndex], .tail = trl[tailIndex + 1 .. tailIndex + 1 + lenOfTail] };
}
